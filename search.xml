<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二叉树的遍历(递归和迭代的C++实现)]]></title>
    <url>%2F2019%2F04%2F18%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3%E7%9A%84C-%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[基于leetcode上的几道题对二叉树的遍历进行复习。 前序遍历(Leetcode 144)先访问根节点，然后遍历左子树，最后遍历右子树。 递归算法12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root)&#123; vector&lt;int&gt; res(0); if(root == nullptr) return res; preorderHelper(root,res); return res; &#125; void preorderHelper(TreeNode* root,vector&lt;int&gt; &amp;res)&#123; if(root == nullptr) return; res.push_back(root-&gt;val); preorderHelper(root-&gt;left,res); preorderHelper(root-&gt;right,res); &#125;&#125;; 迭代算法1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res(0); if(root == nullptr) return res; stack&lt;TreeNode*&gt; tmp; //用栈来模拟递归调用的过程 TreeNode* curNode; tmp.push(root); while(!tmp.empty())&#123; curNode = tmp.top(); res.push_back(curNode-&gt;val); tmp.pop(); // 按右结点、左结点的顺序入栈，这样出栈时就会先访问左子树，再访问右子树 if(curNode-&gt;right != nullptr) tmp.push(curNode-&gt;right); if(curNode-&gt;left != nullptr) tmp.push(curNode-&gt;left); &#125; return res; &#125;&#125;; 中序遍历(Leetcode 94)先遍历左子树，然后访问根节点，最后遍历右子树。 递归算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root)&#123; vector&lt;int&gt; res(0); if(root == nullptr) return res; inorderHelper(root,res); return res; &#125; void inorderHelper(TreeNode* root,vector&lt;int&gt; &amp;res)&#123; if(root == nullptr) return; inorderHelper(root-&gt;left,res); res.push_back(root-&gt;val); inorderHelper(root-&gt;right,res); &#125;&#125;;``` #### 迭代算法```c++/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; tmp; while (!tmp.empty() || root != NULL) &#123; if (root != NULL) &#123; tmp.push(root); root = root-&gt;left; //访问最左节点 &#125; else &#123; root = tmp.top(); res.push_back((tmp.top())-&gt;val); tmp.pop(); root = root-&gt;right; &#125; &#125; return res; &#125;&#125;; 后序遍历(Leetcode 145)先遍历左子树，然后遍历右子树，最后访问根结点 递归算法123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root)&#123; vector&lt;int&gt; res; if(root == nullptr) return res; postorderHelper(root,res); return res; &#125; void postorderHelper(TreeNode* root,vector&lt;int&gt; &amp;res)&#123; if(root == nullptr) return; postorderHelper(root-&gt;left,res); postorderHelper(root-&gt;right,res); res.push_back(root-&gt;val); &#125;&#125;; 迭代算法12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; tmp; TreeNode* curNode = root; if(curNode) tmp.push(root); else return res; while(!tmp.empty())&#123; curNode = tmp.top(); if(curNode-&gt;left) &#123; tmp.push(curNode-&gt;left); curNode-&gt;left = NULL; //将访问过节点的左子树设为空，否则会进入死循环 &#125; else&#123; if(curNode-&gt;right)&#123; tmp.push(curNode-&gt;right); curNode-&gt;right = NULL; &#125; else&#123; res.push_back(curNode-&gt;val); tmp.pop(); &#125; &#125; &#125; return res; &#125;&#125;; 层序遍历(Leetcode 102)1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; que; TreeNode* curNode = root; if(curNode) que.push(curNode); else return res; while(!que.empty())&#123; int size = que.size(); //获取该层节点个数 vector&lt;int&gt; tmp; while(size--)&#123; curNode = que.front(); que.pop(); tmp.push_back(curNode-&gt;val); if(curNode-&gt;left) que.push(curNode-&gt;left); if(curNode-&gt;right) que.push(curNode-&gt;right); &#125; res.push_back(tmp); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>algorithm and data structure</category>
      </categories>
      <tags>
        <tag>binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise On Leetcode]]></title>
    <url>%2F2019%2F04%2F11%2FExercise-On-Leetcode%2F</url>
    <content type="text"><![CDATA[Record my thoughts and solutions to the problems on leetcode. Depth-first SearchEasyleetcode-100思路：判断两颗树相同需两个条件： 当前节点值相同 左子树相同且右子树相同 基于此和树的递归数据结构容易写出递归程序解决该问题。时间复杂度:&emsp;&emsp;O(N) &emsp;//每个节点访问一次空间复杂度:&emsp;&emsp;最好: O(log(N)) (完全平衡二叉树)&emsp;&emsp;最坏: O(N) (退化为链表) &emsp;//N为维护递归栈的深度 代码：c++:123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if(p==NULL &amp;&amp; q==NULL) return true; if(p==NULL || q==NULL) return false; if(p-&gt;val == q-&gt;val)&#123; return isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right); &#125;else&#123; return false; &#125; &#125;&#125;; python:12345678910111213141516# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool: if p==None and q==None: return True if p==None or q==None: return False if p.val == q.val: return self.isSameTree(p.right,q.right) and self.isSameTree(p.left,q.left) else: return False]]></content>
      <categories>
        <category>algorithm and data structure</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
