<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[scrapy分布式爬虫打造搜索引擎（一）——环境配置]]></title>
    <url>%2F2019%2F04%2F26%2Fscrapy%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E6%89%93%E9%80%A0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[开始打造我们的搜索引擎前，先来配置好我们的环境吧！ 开发环境搭建 IDE — pycharm 数据库 — mysql、redis、elasticsearch 开发环境 — virtualenv pycharm的安装和使用 官网安装pycharm(Professional) 使用license server激活pycharm(可参考Jetbrains系列产品2019.1.1最新激活方法) 打开pycharm，在File-Settings下设置熟悉的keymap和相应的interpreter mysql和navicat的安装和使用 官网安装对应系统的mysql (note:记住用户名和密码，后面连接数据库时要用到) 安装navicate，网上破解方法很多，这里不再赘述 命令行下启动mysql mysql -uroot -p 远程访问数据库：linux下修改mysql配置文件 sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf（windows下的配置文件为my.ini）修改其中的bind-address为0.0.0.0(默认为127.0.0.1，即本地) 设置权限,使所有root用户都可以访问数据库,有两条命令 GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;root&#39; WITH GRANT OPTION;和flush privileges; 打开navicat，连接mysql后，新建数据库时注意字符集选择utf8（否则会出现中文乱码），排序规则选择utf8_general_ci 虚拟环境的安装和配置不同项目的环境配置不一样，使用虚拟环境可以很好地解决这个问题。pip install virtualenv /pip install virtualenvwrapper用virualenv和virtualenvwrapper可以很好地进行虚拟环境地配置，具体使用可参考网上教程。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>spider</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历(递归和迭代的C++实现)]]></title>
    <url>%2F2019%2F04%2F18%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86-%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3%E7%9A%84C-%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[基于leetcode上的几道题对二叉树的遍历进行复习。 前序遍历(Leetcode 144)先访问根节点，然后遍历左子树，最后遍历右子树。 递归算法12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root)&#123; vector&lt;int&gt; res(0); if(root == nullptr) return res; preorderHelper(root,res); return res; &#125; void preorderHelper(TreeNode* root,vector&lt;int&gt; &amp;res)&#123; if(root == nullptr) return; res.push_back(root-&gt;val); preorderHelper(root-&gt;left,res); preorderHelper(root-&gt;right,res); &#125;&#125;; 迭代算法1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res(0); if(root == nullptr) return res; stack&lt;TreeNode*&gt; tmp; //用栈来模拟递归调用的过程 TreeNode* curNode; tmp.push(root); while(!tmp.empty())&#123; curNode = tmp.top(); res.push_back(curNode-&gt;val); tmp.pop(); // 按右结点、左结点的顺序入栈，这样出栈时就会先访问左子树，再访问右子树 if(curNode-&gt;right != nullptr) tmp.push(curNode-&gt;right); if(curNode-&gt;left != nullptr) tmp.push(curNode-&gt;left); &#125; return res; &#125;&#125;; 中序遍历(Leetcode 94)先遍历左子树，然后访问根节点，最后遍历右子树。 递归算法123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root)&#123; vector&lt;int&gt; res(0); if(root == nullptr) return res; inorderHelper(root,res); return res; &#125; void inorderHelper(TreeNode* root,vector&lt;int&gt; &amp;res)&#123; if(root == nullptr) return; inorderHelper(root-&gt;left,res); res.push_back(root-&gt;val); inorderHelper(root-&gt;right,res); &#125;&#125;; 迭代算法1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; tmp; while (!tmp.empty() || root != NULL) &#123; if (root != NULL) &#123; tmp.push(root); root = root-&gt;left; //访问最左节点 &#125; else &#123; root = tmp.top(); res.push_back((tmp.top())-&gt;val); tmp.pop(); root = root-&gt;right; &#125; &#125; return res; &#125;&#125;; 后序遍历(Leetcode 145)先遍历左子树，然后遍历右子树，最后访问根结点 递归算法123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root)&#123; vector&lt;int&gt; res; if(root == nullptr) return res; postorderHelper(root,res); return res; &#125; void postorderHelper(TreeNode* root,vector&lt;int&gt; &amp;res)&#123; if(root == nullptr) return; postorderHelper(root-&gt;left,res); postorderHelper(root-&gt;right,res); res.push_back(root-&gt;val); &#125;&#125;; 迭代算法12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; tmp; TreeNode* curNode = root; if(curNode) tmp.push(root); else return res; while(!tmp.empty())&#123; curNode = tmp.top(); if(curNode-&gt;left) &#123; tmp.push(curNode-&gt;left); curNode-&gt;left = NULL; //将访问过节点的左子树设为空，否则会进入死循环 &#125; else&#123; if(curNode-&gt;right)&#123; tmp.push(curNode-&gt;right); curNode-&gt;right = NULL; &#125; else&#123; res.push_back(curNode-&gt;val); tmp.pop(); &#125; &#125; &#125; return res; &#125;&#125;; 层序遍历(Leetcode 102)1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; que; TreeNode* curNode = root; if(curNode) que.push(curNode); else return res; while(!que.empty())&#123; int size = que.size(); //获取该层节点个数 vector&lt;int&gt; tmp; while(size--)&#123; curNode = que.front(); que.pop(); tmp.push_back(curNode-&gt;val); if(curNode-&gt;left) que.push(curNode-&gt;left); if(curNode-&gt;right) que.push(curNode-&gt;right); &#125; res.push_back(tmp); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>algorithm and data structure</category>
      </categories>
      <tags>
        <tag>binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Exercise On Leetcode]]></title>
    <url>%2F2019%2F04%2F11%2FExercise-On-Leetcode%2F</url>
    <content type="text"><![CDATA[Record my thoughts and solutions to the problems on leetcode. Depth-first SearchEasyleetcode-100思路：判断两颗树相同需两个条件： 当前节点值相同 左子树相同且右子树相同 基于此和树的递归数据结构容易写出递归程序解决该问题。时间复杂度:&emsp;&emsp;O(N) &emsp;//每个节点访问一次空间复杂度:&emsp;&emsp;最好: O(log(N)) (完全平衡二叉树)&emsp;&emsp;最坏: O(N) (退化为链表) &emsp;//N为维护递归栈的深度 代码：c++:123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if(p==NULL &amp;&amp; q==NULL) return true; if(p==NULL || q==NULL) return false; if(p-&gt;val == q-&gt;val)&#123; return isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right); &#125;else&#123; return false; &#125; &#125;&#125;; python:12345678910111213141516# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool: if p==None and q==None: return True if p==None or q==None: return False if p.val == q.val: return self.isSameTree(p.right,q.right) and self.isSameTree(p.left,q.left) else: return False leetcode-897思路：考虑到这是一棵二叉搜索树，使用中序遍历的同时将访问的结点连接到结果结点的右子树并将左子树设为空，即可将原二叉树的结点升序输出了。 时间复杂度: O(N) &emsp;//每个节点访问一次空间复杂度: O(H) &emsp;//H为树的高度 代码：c++:1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* increasingBST(TreeNode* root) &#123; if(!root) return NULL; TreeNode dummy(0); p = &amp;dummy; InOrderTravel(root); return dummy.right; &#125; void InOrderTravel(TreeNode* root)&#123; if(!root) return; InOrderTravel(root-&gt;left); p-&gt;right = root; p = root; p-&gt;left = NULL; InOrderTravel(root-&gt;right); &#125;private: TreeNode* p;&#125;; python:1234567891011121314151617181920# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def increasingBST(self, root: TreeNode) -&gt; TreeNode: def inorder(node): if node: inorder(node.left) self.cur.right = node self.cur = node self.cur.left = None inorder(node.right) ans = self.cur = TreeNode(None) inorder(root) return ans.right]]></content>
      <categories>
        <category>algorithm and data structure</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
